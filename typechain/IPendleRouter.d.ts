/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface IPendleRouterInterface extends ethers.utils.Interface {
  functions: {
    "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)": FunctionFragment;
    "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)": FunctionFragment;
    "bootstrapMarket(bytes32,address,address,uint256,uint256)": FunctionFragment;
    "createMarket(bytes32,address,address)": FunctionFragment;
    "data()": FunctionFragment;
    "newYieldContracts(bytes32,address,uint256)": FunctionFragment;
    "redeemAfterExpiry(bytes32,address,uint256)": FunctionFragment;
    "redeemDueInterests(bytes32,address,uint256,address)": FunctionFragment;
    "redeemLpInterests(address,address)": FunctionFragment;
    "redeemUnderlying(bytes32,address,uint256,uint256)": FunctionFragment;
    "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)": FunctionFragment;
    "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)": FunctionFragment;
    "renewYield(bytes32,uint256,address,uint256,uint256)": FunctionFragment;
    "swapExactIn(address,address,uint256,uint256,bytes32)": FunctionFragment;
    "swapExactOut(address,address,uint256,uint256,bytes32)": FunctionFragment;
    "tokenizeYield(bytes32,address,uint256,uint256,address)": FunctionFragment;
    "weth()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addMarketLiquidityDual",
    values: [
      BytesLike,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addMarketLiquiditySingle",
    values: [BytesLike, string, string, boolean, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "bootstrapMarket",
    values: [BytesLike, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createMarket",
    values: [BytesLike, string, string]
  ): string;
  encodeFunctionData(functionFragment: "data", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "newYieldContracts",
    values: [BytesLike, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAfterExpiry",
    values: [BytesLike, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemDueInterests",
    values: [BytesLike, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemLpInterests",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemUnderlying",
    values: [BytesLike, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMarketLiquidityDual",
    values: [
      BytesLike,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMarketLiquiditySingle",
    values: [BytesLike, string, string, boolean, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renewYield",
    values: [BytesLike, BigNumberish, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactIn",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swapExactOut",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenizeYield",
    values: [BytesLike, string, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(functionFragment: "weth", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "addMarketLiquidityDual",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMarketLiquiditySingle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bootstrapMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "data", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "newYieldContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemAfterExpiry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemDueInterests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemLpInterests",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemUnderlying",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMarketLiquidityDual",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMarketLiquiditySingle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "renewYield", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapExactIn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapExactOut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenizeYield",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "weth", data: BytesLike): Result;

  events: {
    "Exit(address,uint256,uint256,address,uint256)": EventFragment;
    "Join(address,uint256,uint256,address,uint256)": EventFragment;
    "MarketCreated(bytes32,address,address,address)": EventFragment;
    "SwapEvent(address,address,address,uint256,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Exit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Join"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapEvent"): EventFragment;
}

export class IPendleRouter extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IPendleRouterInterface;

  functions: {
    addMarketLiquidityDual(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)"(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    bootstrapMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "bootstrapMarket(bytes32,address,address,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "createMarket(bytes32,address,address)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    data(overrides?: CallOverrides): Promise<[string]>;

    "data()"(overrides?: CallOverrides): Promise<[string]>;

    newYieldContracts(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "newYieldContracts(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemAfterExpiry(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "redeemAfterExpiry(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemDueInterests(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "redeemDueInterests(bytes32,address,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemLpInterests(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "redeemLpInterests(address,address)"(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    redeemUnderlying(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "redeemUnderlying(bytes32,address,uint256,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeMarketLiquidityDual(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renewYield(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "renewYield(bytes32,uint256,address,uint256,uint256)"(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactIn(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapExactIn(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapExactOut(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapExactOut(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tokenizeYield(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "tokenizeYield(bytes32,address,uint256,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    weth(overrides?: CallOverrides): Promise<[string]>;

    "weth()"(overrides?: CallOverrides): Promise<[string]>;
  };

  addMarketLiquidityDual(
    _marketFactoryId: BytesLike,
    _xyt: string,
    _token: string,
    _desiredXytAmount: BigNumberish,
    _desiredTokenAmount: BigNumberish,
    _xytMinAmount: BigNumberish,
    _tokenMinAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)"(
    _marketFactoryId: BytesLike,
    _xyt: string,
    _token: string,
    _desiredXytAmount: BigNumberish,
    _desiredTokenAmount: BigNumberish,
    _xytMinAmount: BigNumberish,
    _tokenMinAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addMarketLiquiditySingle(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    forXyt: boolean,
    exactInAsset: BigNumberish,
    minOutLp: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    forXyt: boolean,
    exactInAsset: BigNumberish,
    minOutLp: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  bootstrapMarket(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    initialXytLiquidity: BigNumberish,
    initialTokenLiquidity: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "bootstrapMarket(bytes32,address,address,uint256,uint256)"(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    initialXytLiquidity: BigNumberish,
    initialTokenLiquidity: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createMarket(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "createMarket(bytes32,address,address)"(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  data(overrides?: CallOverrides): Promise<string>;

  "data()"(overrides?: CallOverrides): Promise<string>;

  newYieldContracts(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "newYieldContracts(bytes32,address,uint256)"(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemAfterExpiry(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "redeemAfterExpiry(bytes32,address,uint256)"(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemDueInterests(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "redeemDueInterests(bytes32,address,uint256,address)"(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemLpInterests(
    market: string,
    user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "redeemLpInterests(address,address)"(
    market: string,
    user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  redeemUnderlying(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    amountToRedeem: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "redeemUnderlying(bytes32,address,uint256,uint256)"(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    amountToRedeem: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeMarketLiquidityDual(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    exactInLp: BigNumberish,
    minOutXyt: BigNumberish,
    minOutToken: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)"(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    exactInLp: BigNumberish,
    minOutXyt: BigNumberish,
    minOutToken: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeMarketLiquiditySingle(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    forXyt: boolean,
    exactInLp: BigNumberish,
    minOutAsset: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
    marketFactoryId: BytesLike,
    xyt: string,
    token: string,
    forXyt: boolean,
    exactInLp: BigNumberish,
    minOutAsset: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renewYield(
    forgeId: BytesLike,
    oldExpiry: BigNumberish,
    underlyingAsset: string,
    newExpiry: BigNumberish,
    renewalRate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "renewYield(bytes32,uint256,address,uint256,uint256)"(
    forgeId: BytesLike,
    oldExpiry: BigNumberish,
    underlyingAsset: string,
    newExpiry: BigNumberish,
    renewalRate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactIn(
    tokenIn: string,
    tokenOut: string,
    inTotalAmount: BigNumberish,
    minOutTotalAmount: BigNumberish,
    marketFactoryId: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapExactIn(address,address,uint256,uint256,bytes32)"(
    tokenIn: string,
    tokenOut: string,
    inTotalAmount: BigNumberish,
    minOutTotalAmount: BigNumberish,
    marketFactoryId: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapExactOut(
    tokenIn: string,
    tokenOut: string,
    outTotalAmount: BigNumberish,
    maxInTotalAmount: BigNumberish,
    marketFactoryId: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapExactOut(address,address,uint256,uint256,bytes32)"(
    tokenIn: string,
    tokenOut: string,
    outTotalAmount: BigNumberish,
    maxInTotalAmount: BigNumberish,
    marketFactoryId: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tokenizeYield(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    amountToTokenize: BigNumberish,
    to: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "tokenizeYield(bytes32,address,uint256,uint256,address)"(
    forgeId: BytesLike,
    underlyingAsset: string,
    expiry: BigNumberish,
    amountToTokenize: BigNumberish,
    to: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  weth(overrides?: CallOverrides): Promise<string>;

  "weth()"(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    addMarketLiquidityDual(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountXytUsed: BigNumber;
        amountTokenUsed: BigNumber;
        lpOut: BigNumber;
      }
    >;

    "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)"(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountXytUsed: BigNumber;
        amountTokenUsed: BigNumber;
        lpOut: BigNumber;
      }
    >;

    addMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bootstrapMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "bootstrapMarket(bytes32,address,address,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: CallOverrides
    ): Promise<string>;

    "createMarket(bytes32,address,address)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: CallOverrides
    ): Promise<string>;

    data(overrides?: CallOverrides): Promise<string>;

    "data()"(overrides?: CallOverrides): Promise<string>;

    newYieldContracts(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { ot: string; xyt: string }>;

    "newYieldContracts(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { ot: string; xyt: string }>;

    redeemAfterExpiry(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "redeemAfterExpiry(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemDueInterests(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "redeemDueInterests(bytes32,address,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemLpInterests(
      market: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "redeemLpInterests(address,address)"(
      market: string,
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemUnderlying(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "redeemUnderlying(bytes32,address,uint256,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeMarketLiquidityDual(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        exactOutXyt: BigNumber;
        exactOutToken: BigNumber;
      }
    >;

    "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        exactOutXyt: BigNumber;
        exactOutToken: BigNumber;
      }
    >;

    removeMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        exactOutXyt: BigNumber;
        exactOutToken: BigNumber;
      }
    >;

    "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        exactOutXyt: BigNumber;
        exactOutToken: BigNumber;
      }
    >;

    renewYield(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string, BigNumber] & {
        redeemedAmount: BigNumber;
        amountRenewed: BigNumber;
        ot: string;
        xyt: string;
        amountTokenMinted: BigNumber;
      }
    >;

    "renewYield(bytes32,uint256,address,uint256,uint256)"(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string, BigNumber] & {
        redeemedAmount: BigNumber;
        amountRenewed: BigNumber;
        ot: string;
        xyt: string;
        amountTokenMinted: BigNumber;
      }
    >;

    swapExactIn(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "swapExactIn(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapExactOut(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "swapExactOut(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenizeYield(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber] & {
        ot: string;
        xyt: string;
        amountTokenMinted: BigNumber;
      }
    >;

    "tokenizeYield(bytes32,address,uint256,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber] & {
        ot: string;
        xyt: string;
        amountTokenMinted: BigNumber;
      }
    >;

    weth(overrides?: CallOverrides): Promise<string>;

    "weth()"(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    Exit(
      sender: string | null,
      token0Amount: null,
      token1Amount: null,
      market: null,
      exactInLp: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, BigNumber],
      {
        sender: string;
        token0Amount: BigNumber;
        token1Amount: BigNumber;
        market: string;
        exactInLp: BigNumber;
      }
    >;

    Join(
      sender: string | null,
      token0Amount: null,
      token1Amount: null,
      market: null,
      exactOutLp: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, string, BigNumber],
      {
        sender: string;
        token0Amount: BigNumber;
        token1Amount: BigNumber;
        market: string;
        exactOutLp: BigNumber;
      }
    >;

    MarketCreated(
      marketFactoryId: null,
      xyt: string | null,
      token: string | null,
      market: string | null
    ): TypedEventFilter<
      [string, string, string, string],
      { marketFactoryId: string; xyt: string; token: string; market: string }
    >;

    SwapEvent(
      trader: string | null,
      inToken: null,
      outToken: null,
      exactIn: null,
      exactOut: null,
      market: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, BigNumber, string],
      {
        trader: string;
        inToken: string;
        outToken: string;
        exactIn: BigNumber;
        exactOut: BigNumber;
        market: string;
      }
    >;
  };

  estimateGas: {
    addMarketLiquidityDual(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)"(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    bootstrapMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "bootstrapMarket(bytes32,address,address,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "createMarket(bytes32,address,address)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    data(overrides?: CallOverrides): Promise<BigNumber>;

    "data()"(overrides?: CallOverrides): Promise<BigNumber>;

    newYieldContracts(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "newYieldContracts(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemAfterExpiry(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "redeemAfterExpiry(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemDueInterests(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "redeemDueInterests(bytes32,address,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemLpInterests(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "redeemLpInterests(address,address)"(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    redeemUnderlying(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "redeemUnderlying(bytes32,address,uint256,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeMarketLiquidityDual(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renewYield(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "renewYield(bytes32,uint256,address,uint256,uint256)"(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactIn(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapExactIn(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapExactOut(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapExactOut(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tokenizeYield(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "tokenizeYield(bytes32,address,uint256,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<BigNumber>;

    "weth()"(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addMarketLiquidityDual(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "addMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256,uint256)"(
      _marketFactoryId: BytesLike,
      _xyt: string,
      _token: string,
      _desiredXytAmount: BigNumberish,
      _desiredTokenAmount: BigNumberish,
      _xytMinAmount: BigNumberish,
      _tokenMinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "addMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInAsset: BigNumberish,
      minOutLp: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    bootstrapMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "bootstrapMarket(bytes32,address,address,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      initialXytLiquidity: BigNumberish,
      initialTokenLiquidity: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createMarket(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "createMarket(bytes32,address,address)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    data(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "data()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    newYieldContracts(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "newYieldContracts(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemAfterExpiry(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "redeemAfterExpiry(bytes32,address,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemDueInterests(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "redeemDueInterests(bytes32,address,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemLpInterests(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "redeemLpInterests(address,address)"(
      market: string,
      user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    redeemUnderlying(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "redeemUnderlying(bytes32,address,uint256,uint256)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeMarketLiquidityDual(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "removeMarketLiquidityDual(bytes32,address,address,uint256,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      exactInLp: BigNumberish,
      minOutXyt: BigNumberish,
      minOutToken: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeMarketLiquiditySingle(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "removeMarketLiquiditySingle(bytes32,address,address,bool,uint256,uint256)"(
      marketFactoryId: BytesLike,
      xyt: string,
      token: string,
      forXyt: boolean,
      exactInLp: BigNumberish,
      minOutAsset: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renewYield(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "renewYield(bytes32,uint256,address,uint256,uint256)"(
      forgeId: BytesLike,
      oldExpiry: BigNumberish,
      underlyingAsset: string,
      newExpiry: BigNumberish,
      renewalRate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactIn(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapExactIn(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      inTotalAmount: BigNumberish,
      minOutTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapExactOut(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapExactOut(address,address,uint256,uint256,bytes32)"(
      tokenIn: string,
      tokenOut: string,
      outTotalAmount: BigNumberish,
      maxInTotalAmount: BigNumberish,
      marketFactoryId: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tokenizeYield(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "tokenizeYield(bytes32,address,uint256,uint256,address)"(
      forgeId: BytesLike,
      underlyingAsset: string,
      expiry: BigNumberish,
      amountToTokenize: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    weth(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "weth()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
